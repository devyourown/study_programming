이 텍스트는 내가 클린코드(로버트 C. 마틴)를 읽으며 정리한 것이다.

의미 있는 이름
    소프트웨어에서 이름은 어디에나 쓰이기 때문에, 이름을 잘 짓는 것은
    중요하다.

    첫번째 규칙 - 의도가 분명하게 이름을 지어라
    좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이
    훨씬 더 많기 때문에 좋은 이름을 짓는 것이 더 이득이다. 
    이름을 주의 깊게 살펴 더 나은 이름이 떠오르면 개선하기 바란다.
    변수나 함수 그리고 클래스 이름은 다음 질문에 모두 답해야 한다.
    존재 이유? 수행 기능? 사용 방법?
    경과 시간을 나타내는 좋은 변수:
    int elapsedTimeInDays;
    int daysSinceCreation;
    int fildAgeInDays;

    int d 같은 변수는 함축성이 심해 코드 맥락이 코드 자체에 명시적으로
    드러나지 않는다. 위와 같은 변수는 독자가 d를 나타내는 것이 뭔지 
    알고 있다고 가정한다

    두번째 규칙 - 그릇된 정보를 피하라
    프로그래머는 코드에 그릇된 단서를 남겨서는 안된다. 그릇된 단서는 
    코드의 의미를 흐린다. 나름대로 널리 쓰이는 의미가 있는 단어를
    다른 의미로 사용해도 안 된다. 
    예를 들어, 여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면, 
    accountList라 명명하지 않는다. List는 프로그래머에게 특수한 
    의미이기 때문이다.
    유사한 개념은 유사한 표기법을 사용한다. 이것도 정보다. 일관성이
    떨어지는 표기법은 그릇된 정보다.

    세번째 규칙 - 의미있게 구분하라
    이름이 달라야 한다면 의미도 달라져야 한다.
    연속된 숫자를 덧붙이거나 불용어를 추가하는 방식은 적절치 못하다.
    a1, a2같은 이름은 아무런 정보를 제공하지 못한다.
    불용어인 Data나 Info를 포함한 ProductInfo, ProductData는 
    개념을 구분하지 않은 채 이름만 바꾼 경우다.
    컴파일러만 통과하려고 zork를 theZork로 이름지어서는 안된다.
    불용어는 중복이다. 변수 이름에 variable이라는 단어는 금물이다.
    표 이름에 table이라는 단어 또한 마찬가지다.
    읽는 사람이 차이를 알도록 이름을 지어라
    
    네번째 규칙 - 발음하기 쉬운 이름을 사용하라
    발음하기 어려운 이름은 토론하기 어렵다. 프로그래밍은 사회
    활동이기 때문에 이는 중요하다.
    genymdhms(generate date, year, month, ...)이라는 변수를 사용하기
    보다는 generationTimestamp라는 발음할 수 있는 변수를 사용하자.

    다섯번째 규칙 - 검색하기 쉬운 이름을 사용하라
    문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에
    띄지 않는다는 문제점이 있다. 상수 7을 생각해보면 7을 찾을때
    7이 들어간 파일 이름이나 수식이 모두 검색되기 때문이다. 이런 관점에서 
    긴 이름이 짧은 이름보다 좋다. 검색하기 쉬운 이름이 상수보다 좋다.
    이름 길이는 범위 크기에 비례해야 한다.
    변수나 상수 코드를 여러 곳에서 사용한다면 검색하기 쉬운 이름이 
    바람직하다. 

    여섯번째 규칙 - 인코딩을 피하라
    인코딩은 유형이나 범위 정보를 이름에 넣는 것이다. 메타데이터와 같다.

    일곱번째 규칙 - 자신의 기억력을 자랑하지 마라
    자신만 아는 이름으로 변수를 정하지 마라

    클래스 이름
    클래스 이름과 객체 이름은 명사나 명사구가 적합하다.
    Customer, WikiPage, Account, AddressParse등이 좋은 예다.
    Manager, Processor, Data, Info 등과 같은 단어는 피하고
    동사는 사용하지 않는다.

    메서드 이름
    메소드 이름은 동사나 동사구가 적합하다. 
    postPayment, deletePage, save 등이 좋은 예다.
    접근자, 변경자, 조건자는 javabean 표준에 따라 get,set,is를
    붙인다. 
    생성자를 중복정의(overload)할때는 정적 팩토리 메서드를 사용한다.
    메서드는 인수를 설명하는 이름을 사용한다.
    Complex fulcrumPoint = Complex.FromRealNumber(23.0);
    위 코드가 아래 코드보다 좋다.
    Complex fulcrumPoint = new Complex(23.0);
    생성자 사용을 제한하려면 해당 생성자를 private으로 선언한다.

    여덟번째 규칙 - 기발한 이름은 피하라
    재미난 이름보다 명료한 이름을 선택하라. 특정 문화에서만 
    사용하는 농담은 피하는 편이 좋다. 의도를 분명하고 솔직하게 표현하라.

    아홉번째 규칙  - 한 개념에 한 단어를 사용하라
    추상적인 개념 하나에 단어 하나를 선택해 이를 고수하라.
    똑같은 메소드를 클래스마다 fetch, retrieve, get으로 제각각 부르면
    혼란스럽다. 따라서 메소드 이름은 독자적이고 일관적이어야 한다.
    이름이 다르면 독자는 당연히 클래스도 다르고 타입도 다르리라 생각한다.

    열번째 규칙 - 말장난을 하지마라
    한 단어를 두 가지 목적으로 사용하지 마라. 다른 개념에 같은 단어를
    사용한다면 그것은 말장난에 불과하다. 같은 맥락이 아닌데도 '일관성'을
    고려해 같은 단어를 고집하면 말장난이다.

    11번째 규칙 - 해법 영역에서 가져온 이름을 사용하라
    프로그래머에게 익숙한 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어
    등을 사용해도 괜찮다. 코드를 읽을 사람도 프로그래머이기 때문이다.

    12번째 규칙 - 문제 영역에서 가져온 이름을 사용하라
    적절한 '프로그래머 용어'가 없다면 문제 영역에서 이름을 가져온다.
    우수한 프로그래머와 설계자라면 해법 영역과 문제 영역을 구분할 줄
    알아야 한다. 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서
    이름을 가져와야 한다.

    13번째 규칙 - 의미 있는 맥락을 추가하라
    스스로 의미가 분명한 이름이 없지 않다. 하지만 대다수 이름은 
    그렇지 않다. 그래서 클래스, 함수, 이름 공간에 넣어 맥락을 부여한다.
    모든 방법이 실패하면 마지막 수단으로 접두어를 붙인다.
    접두어를 붙이면 변수가 좀 더 큰 구조에 속한다는 사실이 독자에게
    전해진다. 물론 클래스를 생성하면 더 좋다. 그러면 변수가 좀 더 큰
    개념에 속한다는 사실이 컴파일러에게도 전해진다.

    14번째 규칙 - 불필요한 맥락을 없애라
    '고급 휘발유 충전소'(Gas Station Deluxe)라는 애플리케이션을 짠다고
    가정하자. 모든 클래스 이름을 GSD로 시작하겠다는 생각은 바람직하지
    못하다. 

    마치면서
    좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고 문화적인 배경이 같아야
    한다. 

함수
    어떤 프로그램이든 가장 기본적인 단위가 함수다.

    1번 규칙 - 작게 만들어라!
    함수를 만드는 첫째 규칙은 작게다. 둘째 규칙은 더 작게다.
    함수가 얼마나 짧아야 하느냐고 묻는다면, 각 함수가 이야기
    하나를 표현해야 된다. 다시 말해, if문 while문 등에
    들어가는 블록은 한 줄이어야 한다는 의미다. 대개 거기서 함수를
    호출한다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록
    안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.
    이 말은 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다.

    2번 규칙 - 한 가지만 해라!
    함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을
    해야 한다. 여기서 그 '한 가지'란 지정된 함수 이름 아래에서
    추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.

    3번 규칙 - 함수 당 추상화 수준은 하나로!
    함수가 확실히 '한 가지'작업만 하려면 함수 내 모든 문장의 추상화
    수준이 동일해야 한다. 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 
    사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기
    어려운 탓이다. 근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문이 된다.

    4번 규칙 - 위에서 아래로 코드 읽기:내려가기 규칙
    코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이
    한 단계 낮은 함수가 온다. 즉, 위에서 아래로 프로그램을 읽으면 함수
    추상화 수준이 한 단계씩 낮아진다. 이를 저자는 내려가기 규칙이라 부른다.
    핵심은 짧으면서도 '한 가지'만 하는 함수다.

    5번 규칙 - Switch 문
    본질적으로 Switch 문은 N가지를 처리한다. 불행하게도 switch문을 완전히
    피할 방법은 없다. 하지만 각 switch문을 저차원 클래스에 숨기고 절대로
    반복하지 않는 방법은 있다. 다형성을 이용한다.

    6번 규칙 - 서술적인 이름을 사용하라!
    한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어
    이미 절반은 성공했다. 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.
    이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
    함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다.
    그런 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.
    이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구,
    명사, 동사를 사용한다.

    7번 규칙 - 함수 인수
    함수에서 이상적인 인수 개수는 0개다. 다음은 1개고 다음은 2개다.
    3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다.
    특별한 이유가 있어도 사용하면 안 된다. 인수는 어렵다. 인수는 
    개념을 이해하기 어렵게 만든다. 
    출력 인수는 입력 인수보다 이해하기 어렵다.
    최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다.

    8번 규칙 - 많이 쓰는 단항 형식
    함수에 인수 1개를 넘기는 이유로 가장 흔한 경우는 두 가지다.
    하나는 인수에 질문을 던지는 경우다. 다른 하나는 인수를 뭔가로
    변환해 결과를 반환하는 경우다. 다소 드물게 사용하지만
    그래도 아주 유용한 단항 함수 형식이 이벤트다. 이벤트 함수는
    입력 인수만 있다. 출력 함수는 없다.
    입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.

    9번 규칙 - 플래그 인수
    플래그 인수는 추하다! 함수로 부울 값을 넘긴다는 것은
    플래그가 참이면 이걸 하고 거짓이면 저걸 한다는 말이니까
    이럴 때는 renderForSuite()와 renderForSingleTest()처럼 
    함수를 나누는게 좋다.

    10번 규칙 - 이항 함수
    인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 어렵다.
    물론 이항 함수가 적절한 경우도 있다. 직교 좌표계 점은 일반적으로
    인수 2개를 취한다. 하지만 여기서 인수 2개는 한 값을 표현하는 두 요소다.
    두 요소에는 자연적인 순서도 있다.

    11번 규칙 - 삼항 함수
    인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다.
    반면, 삼항 함수로 어울리는 함수도 존재한다.

    12번 규칙 - 인수 객체
    인수가 2-3개가 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 
    짚어본다. 객체를 생성해 인수를 줄이는 방법이 눈속임이라 여겨질지 모르지만
    그렇지 않다. 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 
    표현하게 된다.

    13번 규칙 - 인수 목록
    때로는 인수 개수가 가변적인 함수도 필요하다. printf()가 좋은 예다.
    가변 인수 전부를 동등하게 취급하면 List 형 인수 하나로 취급할 수 있다.
    이런 논리로 따져보면 printf()는 사실상 이항 함수다. 가변 인수를 
    취하는 모든 함수에 같은 원리가 적용된다.

    14번 규칙 - 동사와 키워드
    단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다. 예를 들어
    write(name)은 누구나 곧바로 이해한다. 
    다른 예는 함수 이름에 키워드를 추가하는 형식이다. 즉, 함수 이름에
    인수 이름을 넣는다. 그러면 인수 순서를 기억할 필요가 없어진다.

    15번 규칙 - 부수 효과를 일으키지 마라!
    부수 효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래
    다른 짓도 하니까.

    16번 규칙 - 출력 인수
    출력 인수는 함수 선언부를 찾아보고 나서야 출력 인수인지 알 수 있다.
    일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면
    함수가 속한 객체 상태를 변경하는 방식을 택한다.

    17번 규칙 - 명령과 조회를 분리하라!
    함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다.
    둘 다 하면 혼란을 초래하기 때문에 그런 함수가 있다면 둘을 분리해
    혼란의 뿌리를 뽑는다.

    18번 규칙 - 오류 코드보다 예외를 사용하라!
    명령 함수에서 오류 코드를 반환하는 방식은 17번 규칙을 미묘하게 위반한다.
    오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로
    코드가 깔끔해진다.
    Try/Catch 블록 뽑아내기
        try/catch 블록은 원래 추하다. 그러므로 try/catch 블록을 별도 함수로 
        뽑아내는 편이 좋다. 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고
        수정하기 쉬워진다.
    오류 처리도 한 가지 작업이다.
        그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다. 함수에
        try 키워드가 있다면 함수는 try 문으로 시작해 catch/finally 
        문으로 끝나야한다.
    Error.java 의존성 자석
        오류 코드를 반환한다는 이야기는 오류 코드를 정의한다는 뜻이다.
        이는 오류 코드 수정시 재컴파일/재배치가 필요하다는 말이다.
        오류 코드 대신 예외를 사용하면 Exception 클래스에서 파생되기 때문에
        문제가 줄어든다.

    19번 규칙 - 반복하지 마라!
    코드가 중복되면 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 유지 보수
    해야되는 곳도 많아진다.

    20번 규칙 - 구조적 프로그래밍
    다익스트라는 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야
    한다고 말했다. 하지만 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다.

    21번 규칙 - 함수를 어떻게 짜죠?
    소프트웨어를 짜는 행위는 여느 글짓기와 비슷하다. 초안은 대개 서투르고
    어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다.
    함수를 짤 때도 마찬가지다. 처음에는 길고 복잡하다. 하지만 그 서투른 
    코드를 빠짐없이 테스트하는 단위 테스트 케이스도 만든다. 그런 다음 
    코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거한다. 메소드를
    줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 한다. 이 와중에도
    코드는 단위 테스트를 통과한다. 처음부터 탁 짜내지 않는다. 그게 가능한 사람은 없으리라.

    결론
    프로그래밍의 기술은 언제나 언어 설계의 기술이다. 예전에도 그랬고 
    지금도 마찬가지다. 대가 프로그래머는 시스템을 구현할 프로그램이 아니라
    풀어갈 이야기로 여긴다. 시스템에서 발생하는 모든 동작을 설명하는 
    함수 계층이 바로 그 언어에 속한다.

주석
    1번째 규칙 - 코드로 의도를 표현하라!
    많은 경우 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다.

    2번째 규칙 - 좋은 주석
    글자 값을 한다고 생각하는 주석을 소개한다. 하지만 정말로 좋은 주석은,
    주석을 달지 않을 방법을 찾아낸 주석이다.
    
    법적인 주석

    정보를 제공하는 주석
    때로는 기본적인 정보를 주석으로 제공하면 편리하다.

    의도를 설명하는 주석 
    때때로 주석은 구현을 이해하게 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다.

    의미를 명료하게 밝히는 주석
    때떄로 모호한 인수나 반환 값은 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다.
    물론 그릇된 주석을 달아놓을 위험은 상당히 높다. 각별히 주의한다.

    결과를 경고하는 주석
    때로 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다.

    TODO 주석 
    앞으로 할 일을 TODO 주석으로 남겨두면 편하다. TODO 주석은 프로그래머가 
    필요하다 여기지만 당장 구현하기 어려운 업무를 기술한다.
    하지만 어떤 용도로 사용하든 시스템에 나쁜 코드를 남겨 놓는 핑계가
    되어서는 안 된다.

    중요성을 강조하는 주석 
    자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조하기 위해서도 주석을 사용한다.

    나쁜 주석
    대다수 주석이 이 범주에 속한다. 일반적으로 대다수 주석은 허술한 코드를
    지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화하는 등 프로그래머가
    주절거리는 독백에서 크게 벗어나지 못한다.

    주절거리는 주석
    특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 하는 주석을
    단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여
    최고의 주석을 달도록 노력한다.

    같은 이야기를 중복하는 주석
    코드와 같은 이야기를 하는 주석은 쓸모없을 뿐더러 해를 가한다.

    오해할 여지가 있는 주석
    때때로 의도는 좋았으나 프로그래머가 딱 맞을 정도로 엄밀하게는 주석을 달지
    못하기도 한다. 이는 다른 프로그래머에게 오해를 불러 일으켜 해를 가한다.

    의무적으로 다는 주석
    모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은
    어리석기 그지없다.

    이력을 기록하는 주석
    때때로 사람들은 모듈을 편집할 때마다 모듈 첫 머리에 주석을 추가한다.
    모듈에 가한 변경을 모두 기록하는 일종의 일지 혹은 로그가 된다.
    옛날에는 소스 코드 관리 시스템이 없어 바람직했지만, 이제는 혼란만
    가중할 뿐이다. 완전히 제거하는 편이 좋다.

    있으나 마나 한 주석
    너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석이다.
    있으나 마나 한 주석을 달려는 유혹에서 벗어나 코드를 정리하라.

    무서운 잡음
    때로는 javadocs도 잡음이다. 단지 문서를 제공해야 한다는 욕심으로 생긴
    잡음.

    함수나 변수로 표현할 수 있다면 주석을 달지마라

    위치를 표시하는 주석
    때때로 프로그래머는 소스 파일에서 특정 위치를 표시하려 주석을 사용한다.
    반드시 필요할 때만, 아주 드물게 사용하는게 좋다.
    배너를 남용하면 독자는 흔한 잡음으로 여겨 무시해 버린다.
    
    닫는 괄호에 주석 
    닫는 괄호에 주석을 달아야겠다는 생각이 들면 대신 함수를 줄이려 시도하자.

    공로를 돌리거나 저자를 표시하는 주석
    소스 코드 관리 시스템이 이를 추적하니 쓸데없이 쓰지 말자

    주석으로 처리한 코드 
    그냥 코드를 삭제하라 잃어버릴 염려는 없다.

    HTML 주석
    HTML 주석은 혐오 그 자체다.

    전역 정보
    주석을 달아야 한다면 근처에 있는 코드만 기술하라. 코드 일부에 주석을 달면서
    시스템의 전반적인 정보를 기술하지마라

    너무 많은 정보
    주석에다 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라.

    모호한 관계
    주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다.

    함수 헤더
    짧은 함수는 긴 설명이 필요 없다. 짧고 한 가지만 수행하며 이름을 잘 붙인 함수가
    주석으로 헤더를 추가한 함수보다 훨씬 좋다.

    비공개 코드에서 Javadocs
    공개하지 않을 코드라면 Javadocs는 쓸모가 없다.

형식 맞추기
    프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다. 코드 형식을 맞추기 위한
    간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다.

    형식을 맞추는 목적
    오늘 구현한 기능이 다음 버전에서 바뀔 확률은 아주 높다. 그런데 오늘 구현한
    코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다.
    맨 처음 잡아놓은 구현 스타일과 가독성 수준은 유지보수 용이성과 확장성에 계속
    영향을 미친다.

    1번째 규칙 - 적절한 행 길이를 유지하라
    세로 길이부터 살펴보자. 소스 코드는 얼마나 길어야 적당할까? 대부분 200줄 정도인
    파일로도 커다란 시스템을 구축할 수 있다. 반드시 지켜야 할 규칙은 아니지만
    작은 파일이 큰 파일보다 이해하기 쉽다.

    2번째 규칙 - 신문기사처럼 작성하라
    아주 좋은 신문 기사를 떠올려보자. 첫 문단은 전체 기사 내용을 요약한다.
    쭉 읽으며 내려가면 세세한 사실이 조금씩 드러난다. 소스 파일도 신문 기사와 
    비슷하게 작성한다. 이름은 간단하면서도 설명이 가능하게 짓는다.
    소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록
    의도를 세세하게 묘사한다.

    3번째 규칙 - 개념은 빈 행으로 분리하라
    각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다.
    생각 사이는 빈 행을 넣어 분리해야 마땅하다. 빈 행이 없으면 코드 가독성은
    현저하게 떨어진다.

    세로 밀집도
    줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀접한
    코드 행은 세로로 가까이 놓여야 한다는 뜻이다.

    수직 거리
    시스템이 무엇을 하는지 이해하고 싶은데, 이 조각 저 조각이 어디에 있는지 
    찾고 기억하느라 시간과 노력을 소모한다.
    서로 밀접한 개념은 세로로 가까이 둬야 한다. 물론 두 개념이 서로 다른
    파일에 속한다면 규칙이 통하지 않는다. 하지만 타당한 근거가 없다면 서로 
    밀접한 개념은 한 파일에 속해야 마땅하다. 이게 바로 protected 변수를
    피해야 하는 이유 중 하나다.
    같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현한다.
    여기서 연관성이란 한 개념을 이해하는 데 다른 개념이 중요한 정도다.

    변수 선언
    변수는 사용하는 위치에 최대한 가까이 선언한다. 우리가 만든 함수는 
    매우 짧으므로 지역 변수는 각 함수 맨 처음에 선언한다.
    루프를 제어하는 변수는 흔히 루프 문 내부에 선언한다.

    인스턴스 필드
    반면, 인스턴스 필드는 클래스 맨 처음에 선언한다. 필드 간에 
    세로로 거리를 두지 않는다. 

    종속 함수
    한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
    또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다.

    개념적 유사성
    어떤 코드는 서로 끌어당긴다. 개념적인 친화도가 높기 때문이다.
    친화도가 높을수록 코드를 가까이 배치한다.

    세로 순서
    일반적으로 함수 호출 종속성은 아래 방향으로 유지한다.
    신문기사와 마찬가지로 가장 중요한 개념을 가장 먼저 표현한다. 

    가로 형식 맞추기
    20자에서 60자 사이인 행이 총 행 수의 40%에 달한다.
    프로그래머는 명백하게 짧은 행을 선호하다. 그러므로 짧은 행이
    바람직하다. 100자나 120자에 달해도 나쁘지 않다. 하지만 그 이상은
    솔직히 주의 부족이다.

    가로 공백과 밀집도
    가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다.
    할당 연산자, 인수, 연산자 우선순위를 위해 공백을 사용한다.

    들여쓰기
    범위로 이뤄진 계층을 표현하기 위해 우리는 코드를 들여쓴다.
    들여쓰는 정도는 계층에서 코드가 자리잡은 수준에 비례한다.
    예를 들어, 클래스,메소드 라는 계층이 있다.

    들여쓰기 무시하기
    간단한 if문, 짧은 while문, 짧은 함수에서 들여쓰기를 무시하고픈
    유혹이 생긴다. 하지만 범위를 제대로 표시하는 것이 훨씬 보기 좋다.

    팀 규칙
    프로그래머라면 각자 선호하는 규칙이 있다. 하지만 팀에 속한다면
    자신이 선호해야 할 규칙은 바로 팀 규칙이다. 좋은 소프트웨어
    시스템은 읽기 쉬운 문서로 이뤄진다는 사실을 기억하라.
    한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는
    신뢰감을 독자에게 줘야 한다.

객체와 자료 구조
    변수를 private으로 정의하는 이유가 있다. 남들이 변수에 의존하지
    않게 만들고 싶어서다. 충동이든 변덕이든, 변수 타입이나 구현을
    맘대로 바꾸고 싶어서다. 그렇다면 왜 수많은 프로그래머가 get 
    함수와 set 함수를 당연하게 public으로 변수를 외부에 노출할까?

    자료 추상화
    변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는
    않는다. 구현을 감추려면 추상화가 필요하다. 형식 논리에 치우쳐
    조회 함수와 설정 함수로 변수를 다룬다고 클래스가 되지는 않는다.
    그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채
    자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.
    자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이
    좋다. 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을
    심각하게 고민해야 한다.

    자료/객체 비대칭
    객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
    자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
    두 정의는 본질적으로 상반된다. 
    (자료 구조를 사용하는)절차적인 코드는 기존 자료 구조를 변경하지
    않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 
    기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
    이 반대도 참이다.
    절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면
    모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를
    추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다.
    다시 말해, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서
    쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.
    분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다.

    디미터 법칙
    디미터 법칙은 잘 알려진 고정 관념으로, 모듈은 자신이 조작하는
    객체의 속사정을 몰라야 한다는 법칙이다. 객체는 자료를 숨기고
    함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면
    안 된다는 의미다.

    기차 충돌
    ctxt.getOptions().getScratchDir().getPath()같은 코드를
    기차 충돌이라 부른다. 조잡하다 여겨지는 방식이므로 피하는
    편이 좋다.

    잡종 구조
    디미터 법칙을 따르며 절반은 객체, 절반은 자료 구조인 
    잡종 구조가 나온다. 이런 잡종 구조는 새로운 함수는 물론이고
    새로운 자료 구조도 추가하기 어렵다. 양쪽에서 단점만
    모아놓은 구조다. 프로그래머가 함수나 타입을 보호할지
    공개할지 확신하지 못해 어중간하게 내놓은 설계에 불과하다.

    구조체 감추기
    객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면
    안된다. 뭔가를 구해서 보여주기 보다 뭔가를 하라고 하자.
    모듈에서 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없이
    만들자. 그러면 디미터 법칙을 위반하지 않는다.

    자료 전달 객체
    자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는
    클래스다. 이런 자료 구조체를 때로는 자료 전달 객체
    Data Transfer Object DTO라 한다. DTO는 굉장히 유용한
    구조체다. 좀 더 일반적인 형태는 빈bean 구조다 빈은
    비공개 변수를 조회/설정 함수로 조작한다. 별다른 이익을
    제공하지 않는다.
    활성 레코드는 DTO의 특수한 형태다. 대개 DTO에 더해
    탐색 함수도 제공한다. 불행히도 이런 자료 구조를 객체로
    취급하는 개발자가 흔하다. 하지만 이는 바람직하지 않다.
    그러면 잡종 구조가 나오기 때문이다. 해결책은 활성 
    레코드는 자료 구조로 취급한다.

    결론
    객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을
    변경하지 않으면서 객체 타입을 추가하기는 쉬운 반면, 기존
    객체에 새 동작을 추가하기는 어렵다. 자료 구조는 이 반대다.
    시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이
    필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을
    추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가
    더 적합하다. 우수한 소프트웨어 개발자는 편견 없이 이 사실을
    이해해 직면한 문제에 최적인 해결책을 선택한다.

오류 처리
    오류 처리는 프로그램에 반드시 필요한 요소 중 하나다.
    뭔가 잘못될 가능성은 늘 존재한다. 뭔가 잘못되면 바로 잡을
    책임은 바로 우리 프로그래머에게 있다.
    오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면
    깨끗한 코드라 부르기 어렵다.

    오류 코드보다 예외를 사용하라
    얼마 전까지만 해도 예외를 지원하지 않는 프로그래밍 언어가
    많았다. 함수를 호출한 즉시 오류를 확인해야 하면 잊어버리기
    쉬워진다 그래서 오류가 발생하면 예외를 던지는 편이 낫다.
    그러면 호출자 코드가 깔끔해진다. 논리가 오류 처리 코드와
    뒤섞이지 않으니까.

    Try-Catch-Finally 문부터 작성하라
    예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 
    시작하는 편이 낫다. 그러면 try 블록에서 무슨 일이 생기든지
    호출자가 기대하는 상태를 정의하기 쉬워진다.
    먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후
    테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면
    자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로
    트랜잭션 본질을 유지하기 쉬워진다.

    미확인unchecked 예외를 사용하라 
    확인된 예외는 안정적인 소프트웨어를 사용하는 데에 반드시
    필요하지 않다는 사실이 분명해졌다. 확인된 오류가 치르는
    비용에 상응하는 이익을 가져다주는지 분명히 따지고 사용
    해야한다. 비용은 OCP를 위반하는 것이다. 일반적인
    애플리케이션은 의존성이라는 비용이 이익보다 크다.

    예외에 의미를 제공하라 
    예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면
    오류가 발생한 원인과 위치를 찾기가 쉬워진다. 실패한
    연산 이름과 실패 유형도 언급한다.

    호출자를 고려해 예외 클래스를 정의하라
    오류를 분류하는 방법은 수없이 많다. 오류가 발생한 위치로
    분류가 가능하다. 외부 API를 사용할 때는 감싸기 기법이
    최선이다. 외부 API를 감싸면 외부 라이브러리와 프로그램
    사이에서 의존성이 크게 줄어든다.

    정상 흐름을 정의하라
    예외가 논리를 따라가기 어렵게 만드는 경우가 있다. 특수
    상황을 처리할 필요가 없게 만드는 것이 중요하다. 클래스를
    만들거나 객체를 조작해 특수 사례를 처리하는 방식을
    특수 사례 패턴이라고 부른다. 그러면 클라이언트 코드가
    예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가
    예외적인 상황을 캡슐화해서 처리하기 때문이다.

    null을 반환하지 마라
    오류를 유발하는 행위 중 첫번째가 null을 반환하는 습관이다.
    null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게
    문제를 떠넘긴다. 누구 하나라도 null확인을 빼먹는다면 
    애플리케이션이 통제 불능에 빠질지도 모른다. 메소드에서
    null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나
    특수 사례 객체를 반환한다. 사용하려는 외부 API가 null을 
    반환한다면 감싸기 메소드를 구현해 예외를 던지거나 특수
    사례 객체를 반환하는 방식을 고려한다.

    null을 전달하지 마라
    메소드에서 null을 반환하는 방식도 나쁘지만 메소드로 null을
    전달하는 방식은 더 나쁘다. 정상적인 인수로 null을 기대하는 
    API가 아니라면 메소드로 null을 전달하는 코드는 최대한 피한다.
    대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히
    처리하는 방법이 없다. 그렇다면 애초에 null을 넘기지 못하도록
    금지하는 정책이 합리적이다.

    결론
    깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.
    이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와
    분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 
    작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면
    독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.

경계
    시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우는
    드물다. 어떤 식으로든 이 외부 코드를 우리 코드에 깔끔하게
    통합해야만 한다.

    외부 코드 사용하기
    인터페이스 제공자와 사용자 사이에는 특유의 긴장이 존재한다.
    제공자는 적용성을 최대한 넓히려 애쓰고 사용자는 자신의 요구에
    집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서
    문제가 생길 소지가 많다.
    경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스
    계열 밖으로 노출되지 않도록 주의한다.

    경계 살피고 익히기
    외부에서 가져온 패키지를 사용하고 싶을 때는 제일 먼저 우리가
    사용할 코드를 테스트하는 편이 바람직하다. 외부 코드를 익히고
    통합하려고 하기 보다 먼저 간단한 테스트 케이스를 작성해 외부
    코드를 익히는 편이 좋다. 이를 학습 테스트라 부른다.
    통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다.

    학습 테스트는 공짜 이상이다.
    학습 테스트에 드는 비용은 없다. 오히려 필요한 지식만 확보하는
    손쉬운 방법이다. 학습 테스트는 공짜 이상이다. 패키지 새 버전이
    나온다면 학습 테스트를 돌려 차이가 있는지 확인한다. 새 버전이
    우리 코드와 호환되지 않으면 학습 테스트가 이 사실을 곧바로 
    밝혀낸다. 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안
    사용하려는 유혹에 빠지기 쉽다.

    아직 존재하지 않는 코드를 사용하기
    때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다.
    우리가 다른 부분의 API를 알지 못할 때 우리가 바라는 인터페이스를
    구현하면 테스트와 더 빠른 개발을 진행할 수 있다.

    깨끗한 경계
    경계에 위치하는 코드는 깔끔히 분리한다. 통제가 불가능한 외부
    패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이
    훨씬 좋다. 자칫하면 외부 코드에 휘둘리고 만다.