JSP(Java server page)
    HTML과 java 코드를 혼합해 파일을 구성한다. 이는 디자이너와의 협업과 
    수정이 용이해 유지보수가 쉽지만, 코드를 노출시킬 수 있는 위험이 있다.
Servlet
    Java를 이용해 html 코드를 만드는 것으로 네트워크 보안 유지와 멀티
    스레드 기능을 그대로 사용할 수 있는 장점이 있지만, 유지 보수가 어렵다.
    
따라서 이 둘을 혼합해 사용한다. 로직과 뷰를 나눈다.

Servlet 사용법
    HttpServlet을 상속하는 클래스를 만들고 그것을 서블릿이라고 한다.
    doGet, doPost 함수를 오버라이딩하여 html 코드를 만든다.

JSP 원리
    JSP페이지 -> 서블릿 클래스의 소스 코드 -> 서블릿 클래스의 클래스 파일 ->
    서블릿 객체 -> 서블릿 
    위 순서로 JSP페이지가 서블릿으로 변환된다. 서버에서 한번 변환되면 그 JSP는
    변환된 서블릿으로 계속 사용하다가 다시 JSP페이지가 바뀌면 위 과정을 다시 한다.

JSP 스크립팅 요소
    스크립틀릿
        <%로 시작해서 %>로 끝나고, 그 사이에 자바 명령문이 들어갑니다.

    익스프레션
        <%=로 시작해서 %>ㄹ 끝나고, 그 사이에 자바 식이 들어갈 수 있습니다.
        이 식은 상수나 변수 이름, 식, 함수가 들어갈 수 있습니다.

    선언부
        <%!로 시작해서 %>로 끝나고, 그 사이에 변수 선언이나 메소드 선언을 쓸 수
        있습니다. 이 변수와 메소드는 JSP 페이지로 부터 변환된 서블릿 클래스의
        멤버가 되기 때문에 final, public, private, protected, static등의 
        키워드를 붙이는 것도 가능합니다. 선언부 안에 변수를 선언할 때는 주의해야
        할 점이 있습니다. JSP페이지로부터 변환된 서블릿 클래스는 기본적으로 
        멀티-스레드 모델로 작동하는데, 이 모델에서는 인스턴스 변수를 선언하면 안
        됩니다. 선언부의 변수가 인스턴스 변수가 되지 않게 조심합니다. 선언부는
        가독성을 위해 </html>뒤로 빼는 것이 좋습니다.

지시자의 문법
    지시자는 JSP의 다른 문법들과는 다른 목적으로 사용됩니다. 웹 컨테이너가
    JSP 페이지를 서블릿 클래스로 변환할 때 필요한 여러 가지 정보를 기술합니다.
    page지시자, include 지시자, taglib 지시자가 있습니다.
    이 세 지시자는 <%@으로 시작하고 %>로 끝납니다. <%@ 바로 다음에는 지시자 
    이름이 옵니다.

    page 지시자는 JSP 페이지 전체에 적용되는 정보를 기술하기 위해 사용됩니다.
    page 지시자의 attribute
        contentType 문서의 종류와 웹 브라우저로 전송될 때 인코딩 타입
        import 스크립팅 요소 안에서 사용할 클래스와 인터페이스를 임포트
        buffer 출력 버퍼의 크기
        autoFlush 출력 버퍼가 모두 찼을때의 동작
        isThreadSafe 싱글-스레드 모드로 작동하기 위해 필요함
        session 세션 참여 여부
        errorPage 에러를 처리할 URL
        isErrorPage 에러를 처리하는 페이지인지 여부
        isELIgnored 익스프레션 언어의 무시/처리 여부
        pageEncoding 인코딩 타입
        info 페이지에 대한 설명
        extends 페이지로부터 생성되는 서블릿 클래스의 슈퍼 클래스 
        language 사용할 프로그래밍 언어 
        deferredSyntaxAllowedAsLiteral #{를 사용했을 때의 에러 발생여부
        trimDirectiveWhitespaces 지시자 바로 다음에 있는 공백 문자를 제거하기 위함

    include 지시자는 다른 JSP 페이지나 HTML 문서를 불러 현재 페이지의
    일부로 만들기 위해 사용합니다. file이라는 애트리뷰트를 사용합니다.

    taglib 지시자는 액션을 사용할 때 사용합니다.

절대 경로 얻는 법
    Servlet : getServletContext().getRealPath("/");
    JSP : application.getRealPath("/");
        application.getContextPath();
파일 기록
    PrintWriter 객체를 사용해 로그 파일을 만들 수 있다.
    new PrintWriter(new FileWriter("path", isExpectedToMakeFile))

주석
    기본 자바의 주석과 <%-- --%>이라는 주석도 사용합니다.
    이 주석은 JSP 페이지에서만 주석입니다. 서블릿으로 변환될 때 사라집니다.

JSP 페이지의 내장 변수
    request와 out 내장 변수
    request는 doGet, doPost 메서드의 첫번째 파라미터와 동일한 역할을 합니다.
    out은 getWriter 메소드를 받은 변수와 같습니다. 이것 말고도 다른 내장 변수도 있습니다.

sendRedirect() vs forward()
sendRedirect는 URL을 웹 브라우저로 보내서 간접적으로 웹 자원을 호출하지만, forward 메소드는
웹 서버 쪽에서 직접 호출합니다.
sendRedirect는 다른 웹 서버 자원도 호출하지만, forward는 같은 웹 서버, 같은 웹 애플리케이션
디렉토리 내에 있는 웹 자원만 호출할 수 있습니다.
sendRedirect는 GET을 이용한 텍스트만 보낼 수 있지만, forward는 객체 형태의 모든 데이터를 
전송할 수 있습니다.


쿠키와 세션
    쿠키와 세션 기술은 모두 두개 이상의 웹 컴포넌트가 데이터를 주고받도록 만들기
    위해서 사용된 기술입니다. 쿠키 기술은 전달할 데이터를 웹 브라우저로 보냈다가
    웹 서버 쪽으로 되돌려 받는 방법을 사용합니다. 세션 기술은 웹 브라우저를 거치지
    않고 웹 서버에 있는 데이터 영역을 통해 데이터를 전달합니다. 세션 기술이
    보안적으로 더 우수하지만 서버에 부담을 줄 수 있습니다. 쿠키 기술은 웹 브라우저를
    이용하기 때문에 서버에 부담을 줄일 수 있습니다.

    쿠키 데이터를 저장하는 방법
    첫째로는 Cookie 클래스의 객체를 만들고 둘째로는 addCookie 메소드를 호출합니다.
    Cookie cookie = new Cookie("cookie-name", "cookie-value");
    위 코드를 통해 쿠키를 만듭니다. 인수는 String 타입입니다.
    response.addCookie(cookie); response를 통해 쿠키를 등록합니다.
    이 메소드를 통해 웹 브라우저로 전송된 쿠키를 저장하는 일은 웹 브라우저가 합니다.
    이 때 웹 브라우저가 웹 서버의 주소도 함께 저장합니다.
    addCookie 메소드 호출문이 HTML 코드 출력 명령문보다 먼저 오는 것이 바람직합니다.

    쿠키 데이터를 조회하는 방법
    웹 브라우저는 웹 서버가 아무런 요청을 하지 않아도 웹 서버로 URL을 보낼 때마다
    그 URL에 포함된 웹 서버의 주소에 해당하는 모든 쿠키를 찾아서 웹 서버로 보냅니다.
    그렇기 때문에 쿠키를 필요로 하는 웹 컴포넌트에서는 그냥 그 쿠키를 받아서 사용하면 됩니다.
    getCookies 메소드를 사용해서 받느넫 request에서 호출합니다.
    Cookie cookies[] = request.getCookies(); 쿠키 데이터가 없을 경우 null을 리턴합니다.
    특정 쿠키를 찾기 위해서는 cookie.getName(); cookie.getValue(); 를 호출합니다.
    웹 브라우저가 실행을 마치면 가지고 있던 쿠키는 모두 지워집니다.
    쿠키는 HTTP 요청 메시지에 포함되어 같이 보내집니다.

    쿠키 데이터를 수정하는 방법
    새로운 쿠키를 저장할 때와 마찬가지로 Cookie 객체를 만들어 addCookie 메소드에 넘겨주면
    웹 브라우저는 자신이 갖고 있던 쿠키 중에 같은 이름의 것이 있으면 그것을 지우고
    새로운 쿠키를 저장할 것입니다.

    쿠키 데이터를 삭제하는 방법
    쿠키 기술에서 데이터를 삭제하는 방법은 상당히 특이합니다. 쿠키를 삭제하는 방법이
    따로 있는 것이 아니라 쿠키의 남은 수명을 0으로 설정하는 방법을 사용해야 합니다.
    쿠키에 수명을 지정해 놓으면 웹 브라우저를 시작하고 끝내는 것과 관계없이 그 쿠키가
    일정기간 동안 보존됩니다. 수명을 지정하기 위해서는 addCookie 호출 전에 setMaxAge라는
    메소드를 호출합니다. 이 메소드에는 쿠키의 남은 수명을 초단위로 넘겨줘야 합니다.
    이 메소드에 0이나 메소드 값을 넘겨줄 수 있습니다. 0을 넘겨주면 똑같은 이름의 쿠키를
    삭제합니다. 음수를 넘겨주면 이 메소드를 호출않은 것과 같이 웹 브라우저가 끝날 때까지
    쿠키를 유지합니다.

    쿠키가 특정 경로명을 갖는 URL로만 전송되도록 하는 방법
    웹 브라우저는 웹 서버로 URL을 보낼 때 그 웹 서버에 속하는 모든 쿠키를 함께 보내는 
    것이 기본적인 동작이지만, 때로는 이런 전송 범위를 좁혀야 할 경우가 있습니다.
    그럴때는 addCookie 메소드 전에 setPath라는 메소드를 호출합니다. 이 메소드는
    특정 경로명을 갖는 URL로만 해당 쿠키가 전송되도록 만드는 기능을 합니다.
    setPath에 넘겨주는 URL은 /로 시작해야하고 /로 끝내는 것이 좋습니다.

    쿠키가 여러 웹 서버로 전송되도록 만드는 방법
    여러 웹 서버가 있는 웹 컴포넌트가 공유해야될 쿠키를 사용할 때 이 방법을 사용합니다.
    이를 위해 addCookie() 전에 setDomain() 이라는 메소드를 호출합니다.
    도메인 이름은 마침표(.)로 시작해야하고 광범위한 도메인은 사용할 수 없습니다.(.com)
    
    주의할 점
    웹 브라우저가 저장할 수 있는 쿠키의 개수는 한정적입니다. 50개가 넘는 쿠키를 만들면
    데이터의 손실로 이어질 수 있습니다.

    세션 기술의 사용방법
    세션은 여러 웹 컴포넌트들이 협력 작업을 시작해서 끝내기까지의 기간을 의미합니다.
    세션 기술은 JSP와 서블릿의 구현 방법이 다릅니다.

    서블릿에서 세션 사용
    request.getSession()이라는 메소드를 호출해 HttpSession 타입의 객체를 리턴합니다.
    이 객체에 setAttribute라는 메소드를 호출해 세션 데이터에 영역을 저장할 수 있습니다.
    이 메소드에는 데이터 이름과 데이터 값을 파라미터로 넘겨줍니다. 데이터 이름은 
    String 타입이어야하고, 값은 객체이기만 하면 어떤 타입이든 상관 없습니다.
    수정할 때도 쿠키와 같이 setAttribute를 사용합니다. 저장된 데이터는 같은 웹
    애플리케이션 디렉터리에 있는 다른 웹 컴포넌트에서도 읽을 수 있습니다. 이 때도
    getSession() 메소드를 사용해 가져옵니다. 진행중인 세션이 없을 때는 새로운 세션을
    시작하지만, 진행중인 세션이 있을 때는 그 세션 정보를 가져옵니다.
    세션 객체에 getAttribute("name")라는 메소드를 호출하면 데이터를 가져올 수 있습니다.
    이 때 리턴 타입은 Object이므로 캐스트 연산을 해야 합니다.
    removeAttribute("name")를 이용하면 데이터를 삭제할 수 있습니다.
    세션이 모든 역할을 마치고 나면 session.invalidate();를 사용해 세션을 끝냅니다.

    세션의 적용 범위
    세션 데이터는 쿠키와 달리 같은 웹 애플리케이션 디렉터리에 있는 웹 컴포넌트들끼리만
    공유할 수 있습니다. 그렇기에 또 다른 웹 애플리케이션 디렉터리에서 또 다른 세션을
    시작할 수 있습니다. 세션을 이런식으로 관리하기 위해 쿠키 형태로 전송되는 세션 아이디
    뒤에 해당 디렉토리의 URL 경로명을 붙여 전송합니다.

    일정기간 동안 사용하지 않으면 자동으로 끝나는 세션
    일정기간 동안 세션이 사용되지 않으면 저절로 끝이나는데 그 기간을 세션의 최대 
    비활성화 기간이라고 합니다. session.getMaxInactiveInterval()로 구할 수 있고
    setMaxInactiveInterval()로 설정할 수 있습니다. 이 때 값은 초단위이고 음수를 넣어주면
    저절로 끝나지 않습니다.

    JSP에서 세션 기술을 사용하는 방법
    JSP 페이지가 서블릿 클래스로 변환될 때 이 메소드를 호출하는 코드가 자동으로 추가됩니다.
    따라서 session 내장 변수를 사용하면 됩니다. 그 이후는 서블릿과 동일합니다.

    세션 기술에서도 웹 브라우저로 세션 아이디를 보낼 때 쿠키형태로 만들어서 전송하고 있는데,
    그 쿠키의 이름은 JSESSIONID 입니다.

    URL 재작성 매커니즘의 사용 방법
    웹 환경에서 쿠키를 사용할 수 없을 때, 이 방법을 사용해 세션 아이디를 전송합니다.
    response.encodeURL(url)을 통해 URL을 재작성합니다. 이 때 url은 웹 애플리케이션
    디렉토리에 속해야하고 웹 브라우저로부터 수신된 쿠키가 하나도 없어야 됩니다. 그렇지 않으면
    본래 URL을 리턴합니다. 이 url로 연결되면 세션을 알아서 유지합니다.

익셉션
    웹 컨테이너에서는 익셉션을 다른 방식으로 관리합니다.

    JSP에서는 page 지시자에서 에러가 발생하는 곳에 
    errorPage 애트리뷰트를 쓰고 isErrorPage를 에러를 
    받는 곳에서 사용합니다. 이 때 받는 곳에서 일정하게 에러를
    출력할 수 있게 response.setStatus(200)을 사용합니다.

    servlet에서는 try/catch문을 사용해 forward를 이용해
    에러페이지로 옮깁니다.

    익셉션 타입별로 에러 페이지를 등록하는 방법
    web.xml 파일에 <error-page>라는 서브 엘리먼트를 쓰고
    그 안에 <exception-type>과 <location>이라는 서브엘리먼트를
    사용합니다. <exception-type>에는 패키지 이름을 포함한 전체
    클래스 이름을 씁니다.

    Http 상태 코드별로 에러 페이지를 등록하는 방법
    익셉션과 같이 <error-page>를 만들고 그 안에 <exception-type>만
    <error-code>로 바꿔 줍니다. <error-code>404</error-code>

    익셉션 message 넘겨주기
    new throw Exception(message)로 넘겨주고 isErrorPage=true로
    설정된 페이지에는 exception 내장변수가 생기므로 이를 이용해
    exception.getMessage()를 통해 받을 수 있다.

서블릿의 라이프 사이클
    서블릿 클래스는 웹 브라우저에 의해 바로 호출되는 것이 아니라,
    일단 서블릿 클래스로부터 서블릿 객체가 만들어지고, 그 객체가
    웹 컨테이너에 의해 초기화된 다음에 호출됩니다. 이렇게 웹
    브라우저의 요청을 처리할 수 있는 상태의 서블릿 객체를 서블릿
    이라고 하는데, 웹 컨테이너는 더 이상 필요치 않은 서블릿은
    메모리로부터 제거하기도 합니다. 이런 과정을 서블릿의
    라이프 사이클이라고 합니다.
    JSP 페이지도 위의 과정을 똑같이 거칩니다.

    서블릿 객체를 생성하고 초기화하는 작업은 서버에 부담을 주기
    때문에 서버는 이미 만들어진 서블릿을 메모리에 남겨두고 
    다음에 또 다른 요청이 오면 바로 불러옵니다.

    웹 컨테이너는 서블릿을 자신이 종료되기 전이나 리로드하기 전에
    그에 속하는 모든 서블릿을 제거합니다. 그리고 그럴 때가 
    아니더라도 서블릿이 차지하고 있던 메모리를 다른 목적에
    사용하기 위해 제거하는 경우도 있습니다.

    초기화 작업과 마무리 작업 단계에 웹 컨테이너에 의해 자동으로
    호출되는 메소드가 있습니다. init()과 destory() 입니다.
    jsp에서는 jspInit()과 jspDestroy()입니다.

    init 메소드의 작성 방법
    public void init() throws ServletException {}으로 작성하면
    됩니다. throws 절은 생략 가능합니다.
    웹 컨테이너가 시작될 때 해당 서블릿 클래스를 읽는 방법은
    web.xml안에 <servlet> 엘리먼트 안에 <load-on-startup>이라는
    엘리먼트를 쓰는 것입니다.

    destroy 메소드의 작성 방법
    public void destroy() {} throws 절은 쓸 수 없습니다.

    서블릿의 초기화 파라미터
    서블릿의 초기화 파라미터란 서블릿의 초기화 작업에 필요한
    데이터를 의미합니다. web.xml안에 넣을 수 있습니다.
    <init-param><param-name><../><param-value><../><../>
    을 <servlet>안에 넣으면 두 개 이상의 초기화 파라미터를
    넘겨줄 수도 있습니다. 서블릿 안에서 이 값을 가져오려면
    getInitParameter("name")을 쓰면 됩니다.

    jpsInit 메소드와 jspDestroy 메소드
    jspInit이 throws를 쓸 수 없는 것 빼고는 서블릿과
    같습니다. 반드시 선언문 안에 기술해야 합니다.

    JSP 페이지의 초기화 파라미터
    <servlet>과 <servlet-mapping>를 web.xml 파일 안에
    만들고 <servlet>안에 <jsp-file>을 만들고 <servlet-mapping>
    안에 <url-pattern>을 넣습니다. <jsp-file>안에는 jsp페이지의
    경로를 넣습니다. 나머지는 서블릿과 동일합니다.
    이렇게 기재한 초기화 파라미터는 jsp에서 getInitParameter
    메소드를 호출해서 가져올 수 있습니다.

    서블릿의 환경 정보를 가져오는 방법
    서블릿 클래스나 JSP의 환경에 관련된 정보는 javax.serlet.getServletContext
    인터페이스 타입의 객체를 이용해서 얻을 수 있습니다. 이는
    getServletContext라는 메소드로 얻을 수 있습니다. 이
    객체에 서버의 많은 환경 정보가 들어있습니다.
    jsp에서는 application 내장 변수가 똑같은 일을 합니다.

    웹 애플리케이션의 초기화 파라미터
    web.xml파일에 <web-app> 바로 아래에 <context-param>
    이라는 서브 엘리먼트에 파라미터를 넣습니다. 이렇게 선언하면
    모든 웹 컴포넌트에서 읽을 수 있습니다.

    로그 메시지를 기록하는 log 메소드
    application.log("message");를 사용하면 logs라는 디렉토리에
    localhost.yyyy-mm-dd.log 라는 이름의 파일에 로그를 기록합니다.

    같은 웹 애플리케이션에 속하는 웹 컴포넌트들끼리 데이터를 주고받는 방법
    ServletContext 인터페이스에 setAttribute, getAttribute, removeAttribute
    메소드는 같은 디렉터리에 있는 웹 컴포넌트들끼리 데이터를 공유할 수
    있게 만들어줍니다.

    setAttribute, getAttribute, removeAttribute 메소드에 대하여
    Servlet과 JSP에서 사용되는 위 메소드는 모두 4세트가 있습니다.
    이들은 서로 다른 클래스/인터페이스에 속하고 데이터가 저장되는 영역이
    서로 다르기 때문에 범위와 용도가 다릅니다.
    1.JSPContext / 범위: 현재 JSP / 
    용도: 같은 JSP 안에 있는 스크립팅 요소와 익스프레션 언어 간의
        데이터 교환
    2.ServletRequest / 범위 : 현재 컴포넌트 및 forward(),include()
    되는 또 다른 웹 컴포넌트
    용도: forward,include 메소드를 통해 데이터 전달
    3.HttpSession / 범위: 같은 세션에 속하는 모든 웹 컴포넌트
    용도: 여러 화면으로 구성되는 앱에서 데이터 전달
    4.ServletContext / 범위: 같은 웹 애플리케이션
    용도: 같은 웹 디렉터리에 속하는 웹 컴포넌트들 간의 데이터 공유

익스프레션 언어(Expression language, EL)
    익스프레션 언어란 식을 중심으로 코드를 기술하는 언어입니다.
    ${} 안에 연산자와 피연산자의 조합을 기술합니다. <%= %>으로 
    표현하는 익스프레션과 익스프레션 언어는 다릅니다. 익스프레션에서는
    자바의 변수 이름을 표현하지만, 익스프레션 언어에서는 애트리뷰트의
    이름으로 해석됩니다. 익스프레션 언어의 단점은 복잡한 데이터
    처리가 불가합니다. 그러므로 이 언어는 데이터 처리 결과를 출력하는
    JSP 페이지에 주로 사용됩니다. 익스프레션 언어를 이용하면
    자바 클래스의 정적 메소드를 호출해서 그 결과를 출력하는 일도
    할 수 있습니다. 이 언어의 유일한 목적은 식을 계산해서 그 결과를
    출력하는 것입니다. 
    여기에서 우리가 주의해야 할 점은 EL식 안에 있는 데이터 이름이
    네 종류의 애트리뷰트 중 어느 것으로도 해석될 수 있다는 사실입니다.
    위의 문제를 해결하기 위해 EL식에 있는 데이터 이름을 해석하는 순서를
    다음과 같이 정해 놓았습니다. 이 순서는 사용 범위가 좁은 애트리뷰터부터
    사용 범위가 넓은 애트리뷰트 순으로 진행됩니다.
    page -> request -> session -> application으로 진행됩니다.
    만약 특정한 애트리뷰트를 출력하고 싶다면 데이터 영역을 직접 표시합니다.
    pageScope.data, requestScopse.data, sessionScope.data, applicationScope.
    data 위의 데이터 영역은 익스프레션 언어의 내장 객체 이름입니다.

    익스프레션 언어의 내장 객체
    EL식 안에서 사용되는 내장 객체는 익스프레션 언어에 속하는 것이고,
    스크립팅 요소 안에서는 사용할 수 없습니다.

    param은 웹 브라우저에서 <Form> 엘리먼트를 통해 입력된 데이터를
    가져올 때 사용하는 내장 객체입니다.
    이 객체의 사용법은 두 가지입니다. ${param.NAME} or ${param["NAME"]}
    똑같은 이름의 데이터가 여러 개 입력될 경우에는 paramValues라는
    내장 객체를 사용해야 됩니다. 사용법은 param과 같지만 인덱스를 표시합니다.
    ${paramValues.NAME[0]}으로 표현할 수 있습니다.
    만약 인덱스에 해당되는 값이 안 들어왔을 때는 에러를 발생시키지 않고
    데이터를 출력하지 않기만 합니다.

    header는 HTTP 요청 메시지에 포함된 HTTP 헤더 값을 가져올 때 사용하는
    내장 객체입니다. param과 사용법이 같습니다. 그런데 이 중 header.name과
    같은 방식은 HTTP 헤더 이름이 자바의 식별자 명명 규칙을 따르지 않는다면
    사용할 수 없습니다. HTTP 헤더가 둘 이상 있을 때는 headerValues 내장
    객체를 사용하면 됩니다.

    cookie는 웹 브라우저가 웹 서버로 보낸 쿠키를 가져올 때 사용하는
    내장 객체입니다. 사용법은 위와 같습니다. 그런데 EL 식이 가져오는 것은
    쿠키의 값이 아니라 쿠키 객체입니다. 쿠키 값을 가져오려면 쿠키 객체에서
    value를 가져옵니다. 이에 더해 domain, path, maxAge라는 값이 있습니다.

    initParam은 웹 애플리케이션의 초기화 파라미터 값을 가져다가 출력할 때
    사용하는 내장 객체입니다. 사용법은 위와 같습니다.

    pageContext는 JSP 페이지의 주변 환경에 대한 정보를 제공하는 객체인데
    내장 객체의 타입이 다른 내장 객체와 다릅니다. PageContext 타입인데,
    get-메소드가 들어 있습니다. 이 메소드들을 호출하려면 get을 제거하고
    나머지 부분만 이용합니다. 예를 들어, getRequest라는 메소드를 호출하려면
    pageContext.request로 사용합니다. 이 방법은 파라미터를 받지 않는
    메소드에서만 사용 가능합니다.

    익스프레션 언어의 연산자로는 기본 자바 연산자와 empty 연산자가 있습니다.
    empty 연산자는 데이터의 존재 유무 여부를 판단합니다. 또한 연산자가
    겹치는 것을 막기 위해 div, mod 등 일부 연산자를 영문 단어 연산자로서
    한번 더 추가해 만들었습니다. 익스프레션 언어에는 char에 해당하는 타입이
    없습니다.
    배열과 List 객체의 데이터 항목은 반드시 대괄호 연산자를 이용해서 가리켜야
    합니다. Map과 자바빈의 프로퍼티는 대괄호 연산자와 마침표 연산자 중
    어느 것을 사용해도 괜찮습니다.

    익스프레션 언어로 자바의 정적 메소드 호출하기
    익스프레션 언어에서 자바의 정적 메소드를 호출하기 위해선 준비 작업이 
    필요합니다. 바로 호출할 정적 메소드를 웹 컨테이너에 함수로 등록하는 것
    입니다. 이러한 함수는 .tld라는 확장자를 갖는 TLD 파일에 등록해야 합니다.
    이런 파일은 web.xml 파일과 달리 하나의 웹 애플리케이션 디렉터리 내에
    여러 개 존재할 수도 있고, 작성 방법도 다릅니다.
    TLD(Tag Library Descriptor)는 태그 라이브러리에 대한 정보의 기술입니다.
    태그란 액션 태그를 말하는 것인데, TLD 파일은 본래 이런 액션 태그를
    등록하기 위해 개발된 것입니다. 하지만 이 파일은 EL 함수를 등록할 때도
    사용할 수 있습니다.
    TLD 파일의 루트 엘리먼트는 <taglib>입니다. 그리고 이 안에 
    <tlib-version>과 <short-name>이라는 두 개의 서브엘리먼트를 반드시 써야
    합니다. 그 다음에 EL 함수를 등록합니다. <taglib> 엘리먼트 아래에
    <function>이라는 서브엘리먼트를 추가하고 <name>, <function-class>,
    <function-signature>라는 3개의 서브 엘리먼트를 추가합니다. 
    <name>안에는 나름대로 정한 EL 함수의 이름을 써야하고, <function-class>
    안에는 정적 메소드가 속한 자바 클래스의 풀네임을 써야 하며, 
    <function-signature> 안에는 정적 메소드의 선언부(리턴, 이름, 인수)를
    적습니다. <taglib> 안에 식별자와 버전을 넣어주면 tld 파일 설정은 끝입니다.
    이제 이 파일을 웹 컨테이너에게 알려주기 위해 web.xml 파일에 등록합니다.
    <web-app>안에 <taglib> 서브엘리먼트를 만들고 그 안에 <taglib-uri>와
    <taglib-location>이라는 서브 엘리먼트를 만드세요.

    EL 함수를 호출하는 방법
    JSP 페이지 안에서 EL 함수를 호출하기 위해서는 taglib 지시자를 써야 합니다.
    그 다음에는 uri와 prefix라는 두 개의 애트리뷰트를 써야 합니다.
    prefix에는 접두어를 등록하며 나중에 EL 식을 만들 때 제일 먼저 접두어를
    쓰고 그 다음에 콜론을 쓰면 됩니다.

표준 액션
    XML 기술을 이용해서 기존의 JSP 문법을 확장하는 메커니즘으로 XML 형태를
    띠고 있기 때문에 액션 태그라고 부릅니다. 액션인 이유는 어떤 동작을
    수행하는 역할을 하기 때문입니다.
    액션의 종류는 크게 두 가지입니다. 표준 액션과 커스텀 액션인데, 표준 액션은
    JSP 페이지에서 바로 사용할 수 있고 커스텀 액션은 별도의 라이브러리를
    설치해야 사용할 수 있습니다. 커스텀 액션은 직접 만들어 사용할 수 있습니다.
    표준 액션과 커스텀 액션은 사용하는 접두어가 다릅니다. 표준 액션은 jsp라는
    접두어가 붙고, 커스텀은 그 밖에 접두어가 붙습니다.
    액션은 웹 컨테이너에서 실행되고 그 결과만 출력합니다.
    액션 태그는 XML 문법을 따릅니다.

    JSP 페이지의 모듈화에 사용되는 표준 액션
    <jsp:include> 사용 방법
    jsp 페이지에 다른 웹 자원을 포함시키고자 할 때 사용하는 표준 액션입니다.
    <jsp:include page="resource.html"/>처럼 이 액션에는 page 애트리뷰트를
    사용합니다. page에는 URL 경로명을 사용하면 됩니다.
    결과로 이 태그의 위치에 resource.html의 내용을 대신 출력합니다.
    JSP 페이지의 지시자 중에 include 지시자가 이 액션과 같은 결과를 냅니다.
    하지만 이 두 문법의 내부적인 작동 방식은 서로 다릅니다. 표준 액션은
    JSP 페이지가 실행될 때 동적으로 해당 웹 자원을 읽어서 포함하지만, 지시자는
    JSP 페이지가 서블릿 클래스로 변환될 때 해당 웹 자원을 읽어서 서블릿 클래스의
    코드의 일부로 만듭니다.

    <jsp:forward> 사용 방법
    JSP 페이지를 실행하다가 다른 JSP 페이지로 제어를 넘기고자 할 때 사용하는
    표준 액션입니다. forward 메소드와 같은 기능을 합니다.
    page 애트리뷰트에 URL을 지정합니다.

    자바빈의 호출에 사용되는 표준 액션
    표준 액션을 이용하면 자바 코드를 작성하지 않고도 자바빈 객체를 만들 수
    있습니다. <jsp:useBean> 표준 액션을 사용해서 할 수 있습니다. 이 액션에는
    기본적으로 두 개의 애트리뷰트를 써야 합니다. id와 class인데, class에는
    사용할 자바빈 클래스의 풀네임을 써야합니다. id는 생성된 자바빈 객체를
    대입할 변수 이름을 지정합니다. 이제 생성된 자바 객체를 이용하기 위해
    <jsp:setProperty>와 <jsp:getProperty>를 사용합니다. set에는 
    name, property, value 애트리뷰트를 사용합니다. name에는 객체가 
    들어있는 변수 이름, property에는 프로퍼티 이름, value에는 값을 넣어줍니다.
    get에는 name과 property만 들어갑니다. get은 가져오는 일만 하는게 아니라
    값을 출력하기까지 합니다.
    표준 액션을 통해 만들어진 자바빈 객체의 생존 범위는 표준 액션이 포함된
    JSP 페이지 내입니다. 이 범위에서는 forward 메소드를 써도 전달이 되지
    않기에 이를 해결하기 위해 <jsp:useBean> 액션에 scope라는 애트리뷰트를
    사용해야 합니다. 이 애트리뷰트에는 네 개의 값 page, request, session,
    application 중 하나를 지정할 수 있습니다. forward를 통해 호출된 JSP 
    페이지 안에서 <jsp:useBean>을 사용하면 그 값을 받아 사용할 수 있습니다.
    useBean 액션은 주어진 scope 영역에 id 값에 해당하는 자바 객체가 없을
    경우에만 새로 만들고, 그 객체가 있으면 그 객체를 가져다가 사용합니다.

    웹 브라우저로부터 입력된 데이터를 자바빈 프로퍼티로 설정하는 방법
    가장 원시적인 방법은 스크립틀릿을 이용해서 value 애트리뷰트에 집어넣는
    것 입니다. 이 때 자바빈 프로퍼티의 타입에 맞게 형변환을 먼저 해야 합니다.
    두번째는 익스프레션 언어를 사용하는 것입니다. value 애트리뷰트에 
    익스프레션 언어를 사용해 집어 넣습니다.
    세번째는 value 애트리뷰트 대신 param이라는 애트리뷰트를 사용합니다.
    마지막으로 와일드 카드 문자인 * 을 사용합니다. property 애트리뷰트 
    값으로 *을 지정하면, 입력된 모든 데이터가 그와 똑같은 이름을 갖는
    자바빈 프로퍼티에 각각 설정됩니다.

    자바빈의 다형성을 활용하는 방법
    표준 액션도 자바빈의 다형성을 지원합니다. class 애트리뷰트는 추상 클래스나 
    인터페이스 타입을 지정할 수 없습니다. 대신 type 애트리뷰트에 지정하면
    사용이 가능합니다.

    애플릿을 불러오는 태그를 만드는 표준 액션
    애플릿이란 웹 서버로부터 웹 브라우저로 다운로드 되어서 실행되는 자바
    클래스의 일종입니다. 이런 애플릿을 웹 브라우저 상에서 실행되도록
    만들기 위해 <jsp:plugin> 액션을 사용합니다.

    스크립팅 요소를 대신하는 표준 액션
    스크립틀릿, 익스프레션, 선언부를 대신하는 표준 액션이 있습니다.
    <jsp:scriptlet>, <jsp:expression>, <jsp:declaration> 입니다.
    지시자와 똑같은 일을 하는 표준 액션도 있습니다. <jsp:directive.page>
    라는 표준 액션은 page 지시자, 그리고 <jsp:directive.include>라는
    표준 액션은 include 지시자와 똑같은 일을 합니다.

JSTL
    JSTL(JSP Standard Tag Library)은 커스텀 액션과 함수를 제공합니다.
    JSTL을 가지고 할 수 있는 대표적인 일은
    간단한 프로그램 로직의 구사(if, for)
    다른 JSP 페이지 호출
    날짜, 시간, 숫자의 포맷
    JSP 페이지 하나를 가지고 여러 가지 언어의 웹 페이지 생성
    데이터베이스로의 입력, 수정, 삭제, 조회
    XML문서의 처리
    문자열을 처리하는 함수 호출

    JSTL은 5개의 작은 라이브러리로 나누어집니다.
    접두어                  기능    
    c      변수 선언, 실행 흐름의 제어 기능을 제공
    fmt    숫자, 날짜, 시간을 포맷하는 기능을 제공
    Sql    데이터베이스의 데이터를 처리하는 기능을 제공
    x      XML 문서를 처리할 때 필요한 기능을 제공
    fn     문자열을 처리하는 함수를 제공 

    코어 라이브러리 사용하기
    <c:set> 사용 방법
    <c:set>은 변수를 선언하고 나서 그 변수에 초기값을 대입하는 기능입니다.
    변수의 타입을 쓰지 않습니다. var, value라는 애트리뷰트를 쓰고, 거기에
    각각 변수의 이름과 초기값을 지정합니다. 이렇게 선언한 변수는 EL 식 안에
    사용할 수 있습니다. 하지만 스크립팅 요소 안에서 사용할 수는 없습니다.
    <c:set>을 이용하면 자바 변수가 되는 것이 아니라, page 데이터 영역의
    애트리뷰트가 되기 때문입니다. 대신 스크립팅 요소 안에서 선언한 변수를
    <c:set> 액션의 value 애트리뷰트에 사용하는 것은 가능합니다.
    다른 데이터 영역에 추가하려면 scope 애트리뷰트를 사용합니다.

    <c:remove> 사용 방법
    <c:set>으로 선언한 변수를 삭제하는 방법이 <c:remove>입니다. 이 액션에
    지울 변수를 포함할 var 애트리뷰트를 쓰면 삭제됩니다. 특정 영역에 있는
    데이터를 삭제하려면 scope를 추가해줍니다.

    <c:if> 사용 방법
    조건식을 test라는 애트리뷰트에 넣어줌으로써 조건식이 참이면 <c:if> 
    시작 태그와 끝 태그 사이에 있는 html 코드가 출력됩니다. 이 때 주의할
    점은 조건식을 EL 식 형태로 기술해야 한다는 것입니다.

    <c:choose> 사용 방법
    이는 자바의 switch문 대신입니다. <c:when>은 case를 대신하고 
    <c:otherwise>는 default 문을 대신합니다. 이 때 c:when에 조건식은
    test 애트리뷰트에 EL식으로 넣어줍니다.

    <c:forEach> 사용 방법
    이는 자바의 for 문을 대신합니다. begin과 end 애트리뷰트로 시작값과
    끝 값을 설정합니다. 변수 값은 var 애트리뷰트에 적습니다. step 
    애트리뷰트로 증가치를 설정할 수 있습니다. 또한 items 애트리뷰트를
    사용해 자바의 향상된 for 문처럼 사용할 수 있습니다. items 안에는
    연속된 데이터를 넣습니다.

    <c:forTokens> 사용 방법
    이는 자바의 for 문과 StringTokenizer 클래스의 기능을 합친 것입니다.
    문자열에 포함된 토큰을 분리해서 각각의 토큰에 대해 반복 처리를 수행합니다.
    items, delims, var라는 3개의 애트리뷰트를 사용합니다. items에는
    문자열을 넣고 delims에는 토큰을 분리하는데 사용할 구획 문자를 기술합니다.
    구획 문자는 한 종류 이상의 문자를 지정할 수도 있습니다.

    <c:catch> 사용 방법
    이는 try 블록과 마찬가지 일을 합니다. 이 액션의 시작 태그와 끝 태그
    사이에 에러가 발생하면 실행의 흐름이 곧바로 끝 태그 다름에 있는 코드로
    넘어갑니다. 이 때 var 애트리뷰트에 에러의 정보를 담은 익셉션 객체가
    담깁니다. catch 문을 대신할 액션은 따로 없습니다. 따라서 <c:if>를
    이용합니다.

    <c:redirect> 사용 방법
    이는 sendRedirect 메소드와 동일한 방법으로 작동합니다. url이라는
    애트리뷰트에 호출할 웹 자원의 URL을 지정합니다. 이 때 <c:param>
    이라는 액션을 이 안에 추가하면 자동으로 쿼리를 추가해줍니다.

    <c:import> 사용 방법
    이 액션을 이용하면 다른 웹 서버에 있는 페이지도 불러올 수 있고,
    JSP가 아닌 다른 웹 자원도 불러올 수 있습니다. 사용 방법은
    위의 <c:redirect>와 같습니다.

    <c:url> 사용 방법
    <c:set>과 마찬가지로 변수의 선언에 사용되는 액션이지만, URL을
    저장하기 위한 변수의 선언에 사용됩니다. 쿼리 스트링를 추가하고
    싶을 때는 <c:param>을 사용합니다.

    <c:out> 사용 방법
    데이터를 출력할 때 사용합니다. 웹 브라우저에 의해 특수 문자로
    해석될 가능성이 있는 <,> 같은 문자를 포함한 데이터는 이 액션으로
    출력하는 것이 좋습니다. 이 때 실제 태그로 사용할거면 escapeXml에
    false를 넣어줍니다. 출력할 데이터의 디폴트 값을 지정할 수 있습니다.
    해당 데이터가 없으면 디폴트 값을 대신 출력합니다. default
    애트리뷰트로 지정할 수 있습니다.

    포매팅 라이브러리 사용하기
    다양한 포맷 요구 사항과 국제화를 지원하는 액션이 포함되어 있습니다.
    
    날짜와 시각을 포맷하는 <fmt:formatData>
    이 액션을 사용하기 위해서는 java.util.Date 클래스 타입의 객체를
    넘겨줘야 합니다. 객체를 만들고 value 애트리뷰트에 EL 식으로 
    넘겨줍니다. 이 때 type이라는 애트리뷰트에 time, date, both라는
    값을 입력해서 날짜,시간,둘 다를 고를 수 있습니다.
    timeStyle, dateStyle이라는 애트리뷰트에 full, long, medium,
    short 라는 네가지 값을 이용해 다른 포맷으로 출력할 수 있습니다.
    pattern이라는 애트리뷰트를 통해 직접 패턴을 지정할 수 있습니다.

    수치를 포맷하는 <fmt:formatNumber>
    값은 value 애트리뷰트에 집어넣습니다. 세 자리마다 쉼표를 하나씩
    첨가하려면 groupingUsed라는 애트리뷰트를 추가하고 그 값을 true로
    지정합니다. 소수점 아래를 원하는 만큼 표현하고 싶을 때는 pattern
    이라는 애트리뷰트를 쓰고 그 값으로 #,0,소수점으로 구성합니다.
    #과0 은 모두 숫자로 채워지는데, #을 사용할 경우 그 위치에 유효숫자
    가 있을 경우에만 숫자로 채웁니다. 반면 0은 유효 숫자가 없으면 0으로
    채웁니다.
    수치를 퍼센트 단위로 표시하고 싶을 때는 type 애트리뷰트에 percent
    라고 씁니다. 이 때 value에 100을 곱하고 %을 붙입니다. type에는
    currency라는 값을 지정할 수 있습니다. 금액에 적합한 포맷으로
    만들어 줍니다. 이때 currencySymbol에 기호를 추가해 값을 표시할 수
    있습니다.

    지역을 설정하는 <fmt:setLocale>
    지역을 설정하기 위해서는 value라는 이름의 애트리튜브를 쓰고,
    그 값으로 언어 코드를 넘겨줍니다.

    시간대를 설정하는 <fmt:timeZone>과 <fmt:setTimeZone>
    지역마다 달라지는 날짜와 시각을 자동으로 계산해서 표시해주는 액션입니다.
    value 애트리뷰트에 특정 시간대에 해당하는 지역 이름을 쓰면 timeZone에
    시작 태그와 끝 태그 사이에서 출력되는 날짜와 시각은 그 지역에 맞게
    표시됩니다. 지역 이름은 TimeZone.getAvailableIDs(); 를 이용해
    알 수 있습니다. setTimeZone을 이용하면 액션이 실행된 다음 모든 코드에
    영향을 미칩니다.

    다국어를 지원하는 <fmt:setBundle>과 <fmt:bundle>
    하나의 JSP 페이지를 가지고 여러 가지 언어의 웹 페이지를 생성합니다.

    POST 메소드로 전송된 한글 데이터를 받기 위한 커스텀 액션 
    setCharacterEncoding()과 같은 역할을 하는 <fmt:requestEncoding>을
    통해 한글 데이터를 받을 수 있습니다. value 애트리뷰트에 값을 설정합니다.

    함수 라이브러리 사용하기
    String에 있는 함수와 비슷하지만 멤버 메소드처럼 사용하지 못하고
    매개값으로 String 값을 넘겨줘야 합니다. 예를 들어 substring()을
    사용하고 싶으면 ${fn:substring("parameter", 3, 6)}처럼 줍니다.

커스텀 액션 만들기
    커스텀 액션을 만드는 방법은 크게 두 가지로 나뉩니다. 하나는 태그 파일을
    작성해서 만드는 방법이고, 다른 하나는 태그 클래스를 작성해서 만드는 방법
    입니다.
    태그 파일이란 JSP 페이지와 비슷한 문법으로 작성하는 텍스트 파일입니다.
    태그 클래스는 자바 프로그래밍 언어의 문법에 따라 작성해야 하는 완전한
    자바 클래스이면서 태그 클래스의 작성 규칙도 지켜야 합니다.
    태그 파일은 특정 디렉터리에 저장만 하면 바로 사용할 수 있지만, 태그
    클래스는 소스 코드를 컴파일하고, 클래스 파일을 특정 디렉터리에 설치한 후
    TLD 파일에 등록하고 그 TLD를 다시 web.xml에 등록해야 합니다.
    대신 태그 파일은 소스 코드가 공개되고 클래스는 공개되지 않습니다.
    웹 컨테이너는 태그 파일을 태그 클래스로 변환시킨 다음에 실행합니다.

    태그 파일을 이용해서 커스텀 액션을 만드는 방법
    태그 파일의 문법은 JSP 페이지와 거의 동일합니다. 
    태그 파일은 반드시 .tag라는 확장자를 갖도록 만듭니다.
    JSP 페이지에서 taglib 지시자에 tagdir 애트리뷰트를 uri 대신 씁니다.

    tag 지시자
    tag 지시자는 태그 파일에만 사용할 수 있는 지시자인데, 웹 컨테이너가
    태그 파일을 처리할 때 필요한 여러 가지 정보를 기술하는 역할을 합니다.
    커스텀 액션이 본체를 갖지 않도록 만들기 위해서는 body-content라는
    이름의 애트리뷰트에 empty라는 값을 지정합니다.
    태그 파일에 한글이 포함되어 있을 때는 pageEncoding 애트리뷰트를
    이용합니다.

    attribute 지시자
    태그 파일에 이 지시자가 있으면 name에 설정한 이름의 애트리뷰트 값이
    태그 파일로 전달됩니다. 이 값을 사용하는 방법은 두 가지입니다.
    첫째, 스크립팅 요소 안에서 자바 변수처럼 사용할 수 있습니다.
    둘째, EL 식 안에서 데이터 이름으로 사용할 수 있습니다.
    만약 문자열이 아닌 다른 타입으로 값을 받고 싶으면 type 애트리뷰트를
    추가해 거기에 원하는 타입을 지정합니다. 필수 애트리뷰트로 만들고
    싶다면 required 애트리뷰트에 true를 지정합니다.

    태그 파일의 내장 변수
    태그 파일도 JSP 처럼 내장 변수를 가지고 있습니다.

    동적 애트리뷰트
    각각의 attribute를 위한 지시자를 쓰는 대신 dynamic-attribute를 tag
    지시자에 지정해서 사용하면 모든 애트리뷰트 값이 이 동적 애트리뷰트에
    전달됩니다. 이는 java.util.Map을 통해 <이름, 값>으로 전달됩니다.
    다음과 같은 EL 식으로 값을 가져올 수 있습니다. ${attrs.color}
    대신 일반 애트리뷰트와 달리 자바 변수로 만들어지지 않습니다.
    값을 사용하려면 Map 객체로 형변환하고 여기서 필요한 값을 뽑고
    그 값을 형에 맞게 또 변환하면 됩니다.

    커스텀 액션의 본체를 처리 
    tag지시자의 body-content는 scriptless나 tagdependent를 사용할 수도
    있습니다. scriptless는 본체에 스크립팅 요소를 사용하면 안된다는 의미고
    tagdependent는 있는 그대로의 텍스트가 본체의 내용으로 취급됩니다.
    본체 내용을 출력하고자 하는 위치에 <jsp:doBody>를 쓰면 출력됩니다.

    변수를 지원하는 커스텀 액션
    태그 파일이 JSP 페이지로부터 데이터를 넘겨주기 위해서 사용하는 것이
    variable 지시자입니다. variable 지시자를 이용해서 변수를 선언하면
    JSP에서 그 변수를 통해 그 값을 사용할 수 있습니다. 변수의 이름은
    name-given이라는 애트리뷰트에 넣습니다. 타입을 선언하지 않은
    변수는 String 타입이 됩니다. 변수의 타입은 variable-class라는 
    애트리뷰트로 지정할 수 있습니다. 이렇게 선언된 변수는 태그 파일과
    넘겨진 JSP 페이지의 커스텀 액션의 본체 안에서만 사용할 수 있습니다.
    만약 이 범위를 넘기고 싶다면 scope라는 애트리뷰트를 추가합니다.
    여기에는 NESTED, AT_BEGIN, AT_END 중 한 값을 지정할 수 있습니다.
    NESTED는 커스텀 액션의 본체 안에서만, AT_BEGIN은 시작 태그 다음
    위치부터, AT_END는 커스텀 액션의 끝 태그 다음 위치부터 사용할 수 
    있다는 의미입니다.
    이 변수를 선언한 다음에는 <c:set>을 사용해서 값을 대입합니다.

    태그 클래스를 이용해서 커스텀 액션을 만드는 방법
    SimpleTag 인터페이스를 구현하는 태그 클래스를 작성합니다.
    SimpleTag 안에는 추상 메소드 5개가 있습니다. 구현하기에
    너무 많은 메소드이기 때문에 SimpleTagSupport라는 구현해 놓은
    클래스를 제공하고 있습니다. 이 클래스를 이용해 태그 클래스를
    만들 때는 doTag 메소드를 반드시 작성해야만 합니다. 이 메소드는
    커스텀 액션이 실행될 때 호출되는 것이기 때문에 커스텀 액션이
    해야 할 일은 이 메소드 안에 기술해 놓으면 됩니다.
    getJSPContext()를 이용하면 JspContext 객체를 리턴합니다.
    이 객체에 대해 getOut 메소드를 호출하면 JspWriter 타입의
    객체가 리턴되는데, 이 객체를 이용하면 HTML을 출력할 수 있습니다.

    애트리뷰트가 있는 태그 클래스
    태그 클래스의 경우에는 각각의 애트리뷰트 값을 받는 메소드를
    따로 선언해야 합니다. public void setColor(String color){}
    처럼 public과 setName으로 애트리뷰트 본래 이름을 set뒤에
    설정해줍니다. 그리고 인수로 값을 받습니다. 보통 이 함수에서
    필드에 값을 설정합니다.

    동적 애트리뷰트 태그 클래스
    태그 클래스에서 동적 애트리뷰트를 사용하려면 setDynamicAttribute
    라는 메소드를 선언하면 됩니다. 커스텀 액션에서 사용한 애트리뷰트
    하나하나에 대해 이 메소드가 한번씩 호출됩니다. 나중에 찾아보기 쉽게
    Map 타입의 필드를 만들어 놓고 거기에 이름과 값을 저장합니다.

    본체가 있는 커스텀 액션을 만드는 태그 클래스
    두 가지 단계가 필요합니다. 첫 번째는 커스텀 액션의 본체 내용을
    가져와야 합니다. 이 일은 getJspBody 메소드를 호출합니다.
    리턴값은 JspFragment 타입의 객체입니다. 두 번째는 이 객체를 
    이용해서 본체의 내용을 출력합니다. 이 일은 invoke 메소드를
    호출해서 할 수 있습니다. 파라미터로 출력 스트림을 넘겨줍니다.
    이 때 null을 넘겨주면 JSP 페이지의 출력에 사용되는 스트림을 
    통해서 출력합니다.

    커스텀 액션의 본체 내용을 조작하는 태그 클래스
    본체 내용을 조작하려면 내용을 문자열로 만든 다음에, 그 문자열을 
    조작합니다. 이 때 사용할 수 있는 것이 StringWriter 클래스입니다.
    invoke 메소드에 StringWriter 객체를 넘겨주면 문자열을 얻을 수
    있습니다.

    변수를 지원하는 커스텀 액션을 만드는 태그 클래스
    태그 클래스에서는 해당 변수의 이름과 값을 page 데이터 영역에 저장해
    놓기만 하면 됩니다. JspContext 객체에 setAttribute 메소드를 호출해
    위의 과정을 진행할 수 있습니다.

    차일드 커스텀 액션
    커스텀 액션 안에 또 다른 커스텀 액션이 포함되도록 만들 때, 
    한 가지 다른 점은 커스텀 액션이 올바른 부모 커스텀 액션 안에서
    사용되고 있는지 확인하는 것입니다.

    태그 라이브러리를 만드는 방법
    1.디렉터리 계층 구조를 만들고 파일들을 그곳에 저장합니다.
    2.TLD 파일을 수정합니다.
    3.디렉터리 계층 구조 전체를 JAR 파일로 만듭니다.

필터와 래퍼
    여러 웹 컴포넌트에 대해 똑같은 사전작업이나 사후작업을 해야 하는
    경우(로그인, 결제 등)를 한 곳에 작성해 놓고 공통으로 사용할 수
    있도록 하는 것이 필터와 래퍼입니다.

    필터란 여과기 역할을 하는 프로그램입니다. 자바 클래스 형태로 구현
    하는데 그래서 필터 클래스라고 합니다. 이 클래스는 인스턴스화 된 후
    초기화된 후 사용됩니다. 초기화된 필터는 웹 브라우저와 컴포넌트
    사이에 위치하게 됩니다. 웹 브라우저가 컴포넌트를 호출하면 필터가
    대신 호출되고 필터는 사전작업을 한 뒤 웹 컴포넌트를 호출합니다.
    웹 컴포넌트가 실행이 마무리되면 제어의 흐름을 다시 필터로 보냅니다.
    필터는 사후작업을 한뒤 브라우저로 응답을 보냅니다. 
    하지만 이 작업 중 필터가 하지 못하는 일이 생깁니다. 바로 오가는
    데이터를 변형하는 일은 하지 못합니다. 그런 일은 래퍼가 필요합니다.

    래퍼란 무언가 포장하는 프로그램입니다. 브라우저와 컴포넌트를 
    오가는 요청 메시지와 응답 메시지를 포장합니다. 래퍼는 래퍼 클래스
    형태로 구현되고 객체의 종류에 따라 요청 래퍼 클래스와 응답 래퍼
    클래스로 나뉘어집니다. 필터가 요청 객체와 응답 객체를 받고 
    그 객체를 래퍼로 포장합니다. 그리고 포장된 래퍼 클래스를 브라우저나
    컴포넌트로 전송합니다.

    필터 클래스의 작성, 설치, 등록
    필터 클래스는 Filter 인터페이스를 구현해야 됩니다. 이 인터페이스
    안에 있는 doFilter 메소드 안에서 사전 작업과 사후 작업 그리고 
    컴포넌트를 호출하는 일을 합니다. 컴포넌트를 호출하는 명령문은
    필터 클래스에서 반드시 작성해야 합니다.
    FilterChain이라는 클래스를 이용해 Filter 들을 연결하고 컴포넌트를
    호출하고 다시 컴포넌트가 응답을 보내면 재귀적으로 Filter들을 돌아가
    웹 브라우저로 응답합니다.

    설치와 등록
    필터 클래스를 작성한 다음에 해야 할 일
    1.필터 클래스를 컴파일합니다.
    2.필터 클래스의 컴파일 결과물을 웹 컨테이너에 설치합니다.
    3.필터 클래스를 web.xml 파일에 등록합니다.

    요청 메시지와 응답 메시지에 포함된 정보 조회하기
    doFilter 안에 ServletRequest와 ServletResponse 파라미터를 통해
    정보를 얻을 수 있습니다. 주의할 점은 ServletResponse에 대해 
    호출하는 메소드는 반드시 chain.doFilter 보다 나중에 호출해야
    합니다. 그래야 응답 메시지 관련 정보가 있기 때문입니다.

    필터 체인의 방향 바꾸기
    로그인 여부를 확인하고 그에 따라 로직을 바꾸는 필터는 sendRedirect나
    forward를 통해 구현할 수 있습니다.

    래퍼 클래스의 작성, 설치, 사용
    래퍼 클래스가 요청 래퍼 클래스와 응답 래퍼 클래스로 나뉠 때 지켜야 할
    규칙이 있습니다. 이들이 각각 HttpServletRequestWrapper와 
    HttpServletResponseWrapper 클래스를 상속해야 합니다. 그리고
    이 두 클래스는 HttpServletRequest와 HttpServletResponse 인터페이스를
    구현하고 있기 때문에 래퍼 클래스가 곧 요청 객체와 응답 객체로 인식될 수
    있습니다.

    요청 래퍼 클래스를 작성
    작성하는 요청 래퍼 클래스에 생성자를 만들고 HttpServletRequest를 
    부모 객체에 넘겨줍니다. super(request);
    이제 클래스 안에 데이터를 변형하는 코드를 써줍니다. 컴포넌트가 입력
    데이터를 가져오기 위해 호출하는 메소드와 똑같은 메소드를 선언하고
    그 안에 써야 합니다. 이렇게 하면 나중에 컴포넌트가 이 메소드를
    요청 객체의 메소드인 줄 알고 호출합니다. 이렇게 하고 난뒤 doFilter
    메소드 안에서 request를 감싸고 파라미터로 보내면 완성입니다.

    응답 래퍼 클래스를 작성
    요청 클래스를 작성할 때와 같습니다.
    다른 점은 웹 컴포넌트에서 데이터를 출력할 때 사용하는 메소드와 똑같은
    선언을 해야 하는 것입니다.

    응답 메시지의 본체 내용을 변형하는 래퍼 클래스
    이 때는 getWriter만 StringWriter를 넣어서 리턴하는 함수로 변형만 
    해주면 html 코드를 쉽게 변형할 수 있습니다.
    